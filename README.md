# Receipt Rewards Processor by Jay Kang :dog:
Hello! Welcome to a receipt processor that was built using Python and Flask. This webservice takes in a JSON format receipt, and returns a JSON object with an ID generated by our code. Using this generated ID, another endpoint can be used to look up the receipt data and return the total rewards points earned.

## Getting Started
**Prerequisites**:
* This project was built using Flask 2.2.2 + Python 3.9.13 + Docker:
* Please make sure your system has Docker installed! If not, instructions to install packages step by step will be explained below

**Installation**:
1. Clone the repo `git clone https://github.com/kangjay88/receiptprocessor.git `
2. Type `docker build --tag fetchreceipts .` in the terminal - this installs the Docker container containing all our dependencies 
3. To run, type `docker run -d -p 5000:5000 receipts` to start our container and test API endpoints
**This will be running against your local host! http://127.0.0.1:5000**
4. `docker ps` checks if any containers are currently running, `docker stop <container-name>` is how to stop running the container
5. Create your own virtual env: `python -m venv venv` This is in Windows syntax 
6. Activate your virtual env: `venv\Scripts\activate` <br/>
  a. Steps 4 and 5 are useful for managing Python projects if your system contains multiple Python projects, which could have different library versions <br/>
  b. This creates an environment independent from previously installed libraries and your operating system. 

**Dependencies: IF DOCKER IS NOT AVAILABLE: Use this code to install necessary dependencies!**
`pip install <dependency>`
* flask
* flask dot-env
* Python - install on https://www.python.org/downloads/
* `pip freeze > requirements.txt` will update and create text containing installed dependencies

## Setup
**config.py**:
The `config.py` contains this code: `import os <br/> basedir = os.path.abspath(os.path.dirname(__name__))`
* Helps find our Flask application's location through our operating system
* Grabbing the absolute path of the directory name
```
class Config:
    FLASK_APP = os.environ.get('FLASK_APP')  
    FLASK_DEBUG = os.environ.get('FLASK_DEBUG') 
    SECRET_KEY = '1234'
```
* The class `Config` is important because it helps set up variables for valuable information our Flask app may need in the future
  * i.e API keys, database passwords, middleware that contains sensitive information
* The `.env` file needs to contain the following, in order for Config class to be stored safely:
```
FLASK_APP = 'app'  
FLASK_DEBUG = True 
SECRET_KEY = '1234'
```

**__init__.py (/app/__init__.py)**:
This is the backbone of the application. Here we are instantiating the Flask object, where `__name__` is tied back to the basedir
```
app = Flask(__name__)
app.register_blueprint(receipts)

app.config.from_object(Config)
```
* register the blueprints of `receipts.py`, so that the instantiation of `app` will have a set of operations at a certain URL prefix 
* Using the `config` attribute, we are passing our own custom `Config` class we made 


## Models 
**Here we have two classes: `class Item` and `class Receipt`**
* These classes each represent a table with certain attributes, where the fields are respective of the receipt requirements and properties (from API.yml file)
* Each class also contains a `@staticmethod` which takes in an object as a dictionary , which then initializes the object's properties using the extracted information
  * Returns a new instance of object Receipt or Item with the extracted information
  * `@staticmethod` is a Python decorator that is used for methods not dependent on the state of the object
* Note imported python libraries which help specify object's field attributes
```
class Receipt:
    retailer: str
    purchaseDate: date
    purchaseTime: time
    items: List[Item]
    total: decimal
    id: str = field(init=False)   # These variables are not automatically initialized by the dataclass
    points: int = field(init=False)
```
* `id` and `point` attributes contain `field(init=False)` due to the instantiation of App, it will look for these attributes from the incoming JSON body, although they have not been created
* Must make boolean False in order to bypass attributes

## Receipts
**receipts.py** <br/>
This is our blueprint, which register a set of operations at a certain url prefix. Here we are creating our API endpoints for our `POST` request and `GET` request.
```
@receipts.route('/process', methods=['POST'])
def process_receipt():
    if not request.is_json:
        return 'The receipt is invalid', 400

    jsonStr = request.get_json()
    receipt = Receipt.from_dict(jsonStr)

    receipt.id = str(uuid4())

    receipt.points = Points.calculate(receipt)

    Repo.store_receipt(receipt)

    return jsonify(
        id=receipt.id
    ), 200

```
In our `POST` method, this is what we are doing:
* Validating if incoming JSON Body is in json format
* Parse the incoming JSON to instantiate an instance of `Receipt` class
* Generate UUID using imported library `(uuid4())`
* Calculate points using our `rules.py` and `Points` class
* Storing information in our `Repo.py` IN MEMORY SOLUTION
* Return UUID as JSON str 

```
@receipts.route('/<id>/points', methods=['GET'])
def get_points(id):
    receipt = Repo.get_receipt(id)

    # validate receipt exists
    if receipt is None:
        return 'No receipt found for that id', 404

    # return the points value
    return jsonify(
        points=receipt.points
    ), 200
```
In our `GET` request, this is what we are doing:
* Looking up what we stored in the repo with generated uuid
* Validating if receipt excists
* Returning the total points value in a JSON str

**rules.py** <br/>
We calculate rules by creating an Object for each rule implemented. Each object contains a `@staticmethod` decorator. <br/>
* Allows for additional rules to be easily implemented later <br/>
**points.py** <br/>
This page contains the `class Points`. Using the `def calculate()` method, will iterate over the rules list and return the total point amount. 

## Repo: In-memory Solution
Our in-memory solution uses a class `Repo` which stores the receipt information into a dictionary. This class contains two static methods: 
```
    @staticmethod
    def store_receipt(receipt : Receipt):
        Repo.receipt_dict[receipt.id] = receipt
        return

    @staticmethod
    def get_receipt(id : int):
        return Repo.receipt_dict.get(id)
```
* `store_receipt()` is used in the `POST` request to store the object receipt in repo
* `get_points(id)` is used in the `GET` request to get the generated uuid

## Things to improve upon:
* The `POST` request validates if the receipt is JSON, but it does not validate whether the JSON contains all the required fields necessary <br/>
  * To improve this, would create statement to iterate through attributes, and generate error if requirements of receipt JSON are not met
* The in-memory solution can be implemented for a database in the future, such as `SQL-Alchemy`

## The Big Question:
**Where and when to calculate points** <br/>
Right now, the points are calculated and stored in the `POST` `/process` call. This means the points will be calculated only once and cached. Multiple "points" calls are efficient with this method. However, if the rules change in the future, all receipts must be re-processed. <br />
If we were to calculate on demand in the `/points` call, this would mean any rule changes would be automatically applied and not re-processed. However, there would be more processing if the rules and receipts remain the same, meaning the same calculation is done multiiple times.

## Contact
Jay Kang - (kang.jay.87@gmail.com)
Project Link: (https://github.com/kangjay88/receiptprocessor.git)

## Acknowledgements
* Flask documentation: (https://flask.palletsprojects.com/en/1.1.x/)
* JSON Body -> Object: (https://jsonformatter.org/json-to-python)
* README.md file inspired by: (https://github.com/othneildrew/Best-README-Template)
